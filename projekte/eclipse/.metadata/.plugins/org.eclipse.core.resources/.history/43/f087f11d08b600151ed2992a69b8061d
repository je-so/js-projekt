/* title: EndlicherAutomat impl

   Implements <EndlicherAutomat>.

   Copyright:
   This program is free software. See accompanying LICENSE file.

   Author:
   (C) 2015 Jörg Seebohn

   file: C-kern/api/proglang/automat.h
    Header file <EndlicherAutomat>.

   file: C-kern/proglang/automat.c
    Implementation file <EndlicherAutomat impl>.
*/

#include "C-kern/konfig.h"
#include "C-kern/api/proglang/automat.h"
#include "C-kern/api/err.h"
#include "C-kern/api/ds/foreach.h"
#include "C-kern/api/ds/inmem/slist.h"
#include "C-kern/api/ds/inmem/node/slist_node.h"
#include "C-kern/api/math/int/power2.h"
#include "C-kern/api/memory/memblock.h"
#include "C-kern/api/memory/pagecache_macros.h"
#include "C-kern/api/test/errortimer.h"
#ifdef KONFIG_UNITTEST
#include "C-kern/api/test/unittest.h"
#endif

typedef struct resource_page_t    resource_page_t;
typedef struct automat_resource_t automat_resource_t;
#define KONFIG_UNITTEST
// forward
#ifdef KONFIG_UNITTEST
static test_errortimer_t s_automat_errtimer;
#endif


// struct: resource_page_t

struct resource_page_t {
   /* variable: next
    * Verlinkt die Seiten zu einer Liste. */
   slist_node_t next;
   /* variable: data
    * Beginn der gespeicherten Daten. Diese sind auf den long Datentyp ausgerichtet. */
   long         data[1];
};

// group: constants

/* define: resource_page_SIZE
 * Die Größe in Bytes einer <resource_page_t>. */
#define resource_page_SIZE (256*1024)

/* define: resource_page_SIZE
 * Die Größe einer <resource_page_t> kodiert als <pagesize_e>. */
#define resource_page_PAGESIZE pagesize_262144

// group: helper-types

slist_IMPLEMENT(_pagelist, resource_page_t, next.next)

// group: lifetime

/* function: new_resourcepage
 * Weist page eine Speicherseite von <buffer_page_SIZE> Bytes zu.
 * Der Speicherinhalt von (*page)->data und (*page)->next sind undefiniert. */
static int new_resourcepage(/*out*/resource_page_t ** page)
{
   int err;
   memblock_t memblock;

   if (! PROCESS_testerrortimer(&s_automat_errtimer, &err)) {
      err = ALLOC_PAGECACHE(resource_page_PAGESIZE, &memblock);
   }

   if (err) goto ONERR;

   // set out
   *page = (resource_page_t*) memblock.addr;

   return 0;
ONERR:
   return err;
}

/* function: free_automatresource
 * Gibt eine Speicherseite frei. */
static int delete_resourcepage(resource_page_t * page)
{
   int err;
   memblock_t memblock = memblock_INIT(resource_page_SIZE, (uint8_t*) page);
   err = RELEASE_PAGECACHE(&memblock);
   (void) PROCESS_testerrortimer(&s_automat_errtimer, &err);
   return err;
}


// struct: automat_resource_t

struct automat_resource_t {
   slist_t  pagelist;   // list of allocated memory pages
   slist_t  pagecache;  // list of free pages not freed, waiting to be reused
   size_t   refcount;   // resources managed by this object used by refcount <automat_t>
   uint8_t* freemem;    // freemem points to end of resource_page_t
                        // addr_next_free_memblock == freemem - freesize)
   size_t   freesize;   // 0 <= freesize <= resource_page_SIZE - offsetof(resource_page_t, data)
};

// group: lifetime

/* define: automat_resource_FREE
 * Statischer Initialisierer. */
#define automat_resource_FREE \
         { slist_INIT, slist_INIT, 0, 0, 0 }

static int init_automatresource(/*out*/automat_resource_t * res)
{
   res->pagelist = (slist_t) slist_INIT;
   res->pagecache = (slist_t) slist_INIT;
   res->refcount = 0;
   res->freemem  = 0;
   res->freesize = 0;
   return 0; // TODO: change into void (rename automat_resource_FREE into automat_resource_INIT)
}

/* function: free_automatresource
 * Gibt alle belegten (Speicher-)Ressourcen frei. */
static int free_automatresource(automat_resource_t * res)
{
   int err = 0;
   int err2;

   // append res->pagecache to res->pagelist
   // and clear res->pagecache
   splice_pagelist(&res->pagelist, &res->pagecache);

   // free allocated pages
   foreach (_pagelist, page, &res->pagelist) {
      err2 = delete_resourcepage(page);
      if (err2) err = err2;
   }
   res->pagelist = (slist_t) slist_INIT;
   res->freesize = 0;

   if (err) goto ONERR;

   return 0;
ONERR:
   TRACEEXITFREE_ERRLOG(err);
   return err;
}

// group: usage

/* function: markinuse_automatresource
 * Markiert die Ressourcen, verwaltet von res, als vom aufrufenden <automat_t> benutzt. */
static inline void markinuse_automatresource(automat_resource_t * res)
{
   ++ res->refcount;
}

/* function: markinuse_automatresource
 * Markiert die Ressourcen, verwaltet von res, als vom aufrufenden <automat_t> unbenutzt. */
static inline void clearinuse_automatresource(automat_resource_t * res)
{
   assert(res->refcount > 0);
   -- res->refcount;

   if (0 == res->refcount) {
      splice_pagelist(&res->pagecache, &res->pagelist);
      res->freesize = 0;
   }
}

// group: resource helper

/* function: allocpage_automatresource
 * Weist page eine Speicherseite von <buffer_page_SIZE> Bytes zu.
 * Der Speicherinhalt von **page ist undefiniert. */
static inline int getfreepage_automatresource(automat_resource_t * res, /*out*/resource_page_t ** free_page)
{
   int err;

   if (! isempty_slist(&res->pagecache)) {
      err = removefirst_pagelist(&res->pagecache, free_page);
   } else {
      err = new_resourcepage(free_page);
   }
   if (err) goto ONERR;

   insertlast_pagelist(&res->pagelist, *free_page);

   return 0;
ONERR:
   return err;
}

// group: allocate resources

static int allocmem_automatresource(automat_resource_t * res, uint16_t mem_size, /*out*/void ** mem_addr)
{
   int err;
   resource_page_t * free_page;

   if (res->freesize < mem_size) {
      err = getfreepage_automatresource(res, &free_page);
      if (err) goto ONERR;
      res->freemem  = resource_page_SIZE + (uint8_t*) free_page;
      res->freesize = resource_page_SIZE - offsetof(resource_page_t, data);

      static_assert( (resource_page_SIZE - offsetof(resource_page_t, data)) >= UINT16_MAX,
                     "free page always meets demand of mem_size bytes which could as big as UINT16_MAX"
                     );

   }

   const size_t freesize = res->freesize;
   res->freesize = freesize - mem_size;

   // set out
   *mem_addr = res->freemem - freesize;

   return 0;
ONERR:
   TRACEEXIT_ERRLOG(err);
   return err;
}


// section: automat_t

// group: static variables

#ifdef KONFIG_UNITTEST
/* variable: s_automat_errtimer
 * Simuliert Fehler in Funktionen für <automat_t> und <automat_resource_t>. */
static test_errortimer_t   s_automat_errtimer = test_errortimer_FREE;
#endif

// group: lifetime



// section: Functions

// group: test

#ifdef KONFIG_UNITTEST

static int test_resourcepage(void)
{
   resource_page_t * page[10] = { 0 };
   const size_t      oldsize = SIZEALLOCATED_PAGECACHE();

   // === group constants

   // TEST resource_page_SIZE
   TEST(0 < resource_page_SIZE);
   TEST(ispowerof2_int(resource_page_SIZE));

   // TEST resource_page_PAGESIZE
   TEST(resource_page_SIZE == pagesizeinbytes_pagecache(resource_page_PAGESIZE));

   // === group helper types

   // TEST pagelist_t
   resource_page_t pageobj[10];
   slist_t         pagelist = slist_INIT;
   for (unsigned i = 0; i < lengthof(pageobj); ++i) {
      insertlast_pagelist(&pagelist, &pageobj[i]);
      TEST(&pageobj[i].next == pagelist.last);
      TEST(pageobj[i].next.next == &pageobj[0].next);
      TEST(pageobj[i ? i-1 : 0].next.next == &pageobj[i].next);
   }

   // === group lifetime

   // TEST new_resourcepage
   for (unsigned i = 0; i < lengthof(page); ++i) {
      TEST(0 == new_resourcepage(&page[i]));
      // check env
      TEST(SIZEALLOCATED_PAGECACHE() == oldsize + (i+1) * resource_page_SIZE);
      // check page
      TEST(0 != page[i]);
   }

   // TEST delete_resourcepage
   for (unsigned i = lengthof(page)-1; i < lengthof(page); --i) {
      TEST(0 == delete_resourcepage(page[i]));
      TEST(SIZEALLOCATED_PAGECACHE() == oldsize + i * resource_page_SIZE);
   }

   // TEST new_resourcepage: simulated ERROR
   for (int i = 10; i < 13; ++i) {
      resource_page_t * errpage = 0;
      init_testerrortimer(&s_automat_errtimer, 1, i);
      TEST(i == new_resourcepage(&errpage));
      // check
      TEST(0 == errpage);
      TEST(SIZEALLOCATED_PAGECACHE() == oldsize);
   }

   // TEST delete_resourcepage: simulated ERROR
   for (int i = 10; i < 13; ++i) {
      init_testerrortimer(&s_automat_errtimer, 1, i);
      TEST(i == delete_resourcepage(page[0]));
      TEST(SIZEALLOCATED_PAGECACHE() == oldsize);
   }

   return 0;
ONERR:
   return EINVAL;
}

static int test_automatresource(void)
{
   automat_resource_t res = automat_resource_FREE;
   const size_t       oldsize = SIZEALLOCATED_PAGECACHE();

   // === group lifetime

   // TEST automat_resource_FREE
   TEST( isempty_slist(&res.pagelist));
   TEST( isempty_slist(&res.pagecache));
   TEST( 0 == res.refcount);
   TEST( 0 == res.freemem);
   TEST( 0 == res.freesize);

   // TEST init_automatresource
   memset(&res, 255, sizeof(res));
   init_automatresource(&res);
   // check res
   TEST( isempty_slist(&res.pagelist));
   TEST( isempty_slist(&res.pagecache));
   TEST( 0 == res.refcount);
   TEST( 0 == res.freemem);
   TEST( 0 == res.freesize);

   // TEST free_automatresource
   for (int i = 0; i < 3; ++i) {
      resource_page_t * page;
      TEST(0 == new_resourcepage(&page));
      insertlast_pagelist(&res.pagelist, page);
      TEST(0 == new_resourcepage(&page));
      insertlast_pagelist(&res.pagecache, page);
   }
   TEST(SIZEALLOCATED_PAGECACHE() == oldsize + 6 * resource_page_SIZE);
   res.freesize = 10;
   TEST( 0 == free_automatresource(&res));
   TEST( isempty_slist(&res.pagelist));
   TEST( isempty_slist(&res.pagecache));
   TEST( 0 == res.freesize);
   TEST( SIZEALLOCATED_PAGECACHE() == oldsize);

   // TEST free_automatresource: double free
   res.freesize = 10;
   TEST( 0 == free_automatresource(&res));
   TEST( isempty_slist(&res.pagelist));
   TEST( isempty_slist(&res.pagecache));
   TEST( 0 == res.freesize);
   TEST( SIZEALLOCATED_PAGECACHE() == oldsize);

   // TEST free_automatresource: simulated error
   for (int i = 0; i < 3; ++i) {
      resource_page_t * page;
      TEST(0 == new_resourcepage(&page));
      insertlast_pagelist(&res.pagelist, page);
      TEST(0 == new_resourcepage(&page));
      insertlast_pagelist(&res.pagecache, page);
   }
   TEST(SIZEALLOCATED_PAGECACHE() == oldsize + 6 * resource_page_SIZE);
   init_testerrortimer(&s_automat_errtimer, 2, 7);
   res.freesize = 10;
   TEST( 7 == free_automatresource(&res));
   TEST( isempty_slist(&res.pagelist));
   TEST( isempty_slist(&res.pagecache));
   TEST( 0 == res.freesize);
   TEST( SIZEALLOCATED_PAGECACHE() == oldsize);

   // === group usage

   // TEST markinuse_automatresource
   for (unsigned i = 1; i < 100; ++i) {
      automat_resource_t old;
      memcpy(&old, &res, sizeof(res));
      markinuse_automatresource(&res);
      // check res refcount
      TEST(i == res.refcount);
      // check res nothing changed except refcount
      ++ old.refcount;
      TEST(0 == memcmp(&old, &res, sizeof(res)));
   }

   // TEST clearinuse_automatresource
   for (size_t pl_size = 0; pl_size <= 3; pl_size += 3) {
      for (size_t pc_size = 0; pc_size <= 2; pc_size += 2) {
         resource_page_t * page[5] = { 0 };
         size_t            p_size  = 0;
         // prepare
         for (unsigned i = 0; i < pc_size; ++i, ++p_size) {
            TEST(0 == new_resourcepage(&page[p_size]));
            insertlast_pagelist(&res.pagecache, page[p_size]);
         }
         for (unsigned i = 0; i < pl_size; ++i, ++p_size) {
            TEST(0 == new_resourcepage(&page[p_size]));
            insertlast_pagelist(&res.pagelist, page[p_size]);
         }
         res.freesize = 99;
         res.refcount = 10;
         automat_resource_t old;
         memcpy(&old, &res, sizeof(res));
         for (unsigned i = 9; i; --i) {
            // test refcount > 1
            clearinuse_automatresource(&res);
            // check res refcount
            TEST(i == res.refcount);
            // check res other field not changed
            -- old.refcount;
            TEST(0 == memcmp(&old, &res, sizeof(res)));
         }
         // test refcount == 1
         clearinuse_automatresource(&res);
         // check res
         TEST( isempty_slist(&res.pagelist));
         TEST( (p_size == 0) == isempty_slist(&res.pagecache));
         TEST( 0 == res.refcount);
         TEST( 0 == res.freesize);
         slist_node_t * it = last_slist(&res.pagecache);
         for (unsigned i = 0; i < p_size; ++i) {
            it = next_slist(it);
            TEST(it == (void*) page[i]);
         }
         // reset
         TEST(0 == free_automatresource(&res));
      }
   }

   // === group resource helper

   // prepare
   init_automatresource(&res);
   resource_page_t * page[10];

   // TEST getfreepage_automatresource: pagecache is empty
   for (unsigned i = 0; i < lengthof(page); ++i) {
      TEST(0 == getfreepage_automatresource(&res, &page[i]));
      // check res
      TEST(page[i] == (void*) last_slist(&res.pagelist));
      TEST( isempty_slist(&res.pagecache));
      TEST(0 == res.refcount);
      TEST(0 == res.freemem);
      TEST(0 == res.freesize);
      // check page
      TEST(page[i] == (void*) next_slist(&page[i?i-1:0]->next));
      TEST(page[0] == (void*) next_slist(&page[i]->next));
   }

   // TEST getfreepage_automatresource: pagecache is not empty
   // prepare
   splice_slist(&res.pagecache, &res.pagelist);
   for (unsigned i = 0; i < lengthof(page); ++i) {
      resource_page_t * cached_page;
      TEST(0 == getfreepage_automatresource(&res, &cached_page));
      // check res
      TEST(page[i] == (void*) last_slist(&res.pagelist));
      if (i == lengthof(page)-1) {
         TEST( isempty_slist(&res.pagecache));
      } else {
         TEST( page[i+1] == (void*) first_slist(&res.pagecache));
      }
      TEST(0 == res.refcount);
      TEST(0 == res.freemem);
      TEST(0 == res.freesize);
      // check cached_page
      TEST(page[i] == cached_page);
   }

   // TEST getfreepage_automatresource: simulated ERROR
   {
      resource_page_t * dummy = 0;
	   automat_resource_t old;
	   memcpy(&old, &res, sizeof(res));
	   TEST( isempty_slist(&res.pagecache));
      init_testerrortimer(&s_automat_errtimer, 1, 8);
	   TEST(8 == getfreepage_automatresource(&res, &dummy));
	   // check res not changed
      TEST(0 == memcmp(&old, &res, sizeof(res)));
      TEST(0 == dummy);
   }

   // reset
   TEST(0 == free_automatresource(&res));

   // === group allocate resources

   // TEST allocmem_automatresource
   // TODO: allocmem_automatresource

   return 0;
ONERR:
   return EINVAL;
}

static int test_initfree(void)
{
   automat_t ndfa = automat_FREE;

   // TEST automat_FREE
   TEST(0 == ndfa.nrstates);

   return 0;
ONERR:
   return EINVAL;
}

int unittest_proglang_automat()
{
   if (test_resourcepage())      goto ONERR;
   if (test_automatresource())   goto ONERR;
   if (test_initfree())          goto ONERR;

   return 0;
ONERR:
   return EINVAL;
}

#endif
