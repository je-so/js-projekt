/* title: ErrorContext impl

   Implements <ErrorContext>.

   about: Copyright
   This program is free software.
   You can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   Author:
   (C) 2013 JÃ¶rg Seebohn

   file: C-kern/api/context/errorcontext.h
    Header file <ErrorContext>.

   file: C-kern/context/errorcontext.c
    Implementation file <ErrorContext impl>.
*/

#include "C-kern/konfig.h"
#include "C-kern/api/context/errorcontext.h"
#include "C-kern/api/err.h"
#ifdef KONFIG_UNITTEST
#include "C-kern/api/test.h"
#endif


// section: errorcontext_t

// group: variables

// generated by text resource compiler
#define KONFIG_de de
#define KONFIG_en en
#include STR(C-kern/resource/generated/errtab.KONFIG_LANG)
#undef KONFIG_de
#undef KONFIG_en


// group: lifetime

int init_errorcontext(/*out*/errorcontext_t * errcontext)
{
   errcontext->stroffset = g_errorcontext_stroffset ;
   errcontext->strdata   = g_errorcontext_strdata ;
   return 0 ;
}

int free_errorcontext(errorcontext_t * errcontext)
{
   errcontext->stroffset = 0 ;
   errcontext->strdata   = 0 ;
   return 0 ;
}


// group: test

#ifdef KONFIG_UNITTEST

static int test_initfree(void)
{
   errorcontext_t errcontext = errorcontext_INIT_FREEABLE ;

   // TEST errorcontext_INIT_FREEABLE
   TEST(0 == errcontext.stroffset) ;
   TEST(0 == errcontext.strdata) ;

   // TEST errorcontext_INIT_STATIC
   errcontext = (errorcontext_t) errorcontext_INIT_STATIC ;
   TEST(errcontext.stroffset == g_errorcontext_stroffset) ;
   TEST(errcontext.strdata   == g_errorcontext_strdata) ;

   // TEST init_errorcontext
   errcontext = (errorcontext_t) errorcontext_INIT_FREEABLE ;
   TEST(0 == init_errorcontext(&errcontext)) ;
   TEST(errcontext.stroffset == g_errorcontext_stroffset) ;
   TEST(errcontext.strdata   == g_errorcontext_strdata) ;

   // TEST free_errorcontext
   TEST(0 == free_errorcontext(&errcontext)) ;
   TEST(0 == errcontext.stroffset) ;
   TEST(0 == errcontext.strdata) ;
   TEST(0 == free_errorcontext(&errcontext)) ;
   TEST(0 == errcontext.stroffset) ;
   TEST(0 == errcontext.strdata) ;

   return 0 ;
ONABORT:
   return EINVAL ;
}

static int test_query(void)
{
   errorcontext_t errcontext = errorcontext_INIT_FREEABLE ;

   // prepare
   TEST(0 == init_errorcontext(&errcontext)) ;

   // TEST maxsyserrnum_errorcontext
   TEST(0   <  maxsyserrnum_errorcontext()) ;
   TEST(255 >= maxsyserrnum_errorcontext()) ;
   for (size_t i = maxsyserrnum_errorcontext()+1; i <= 255; ++i) {
      char buffer[50] ;
      snprintf(buffer, sizeof(buffer), "Unknown error %d", (int)i) ;
      TEST(0 == strcmp(strerror((int)i), buffer)) ;
      const char * errstr = (const char*) (g_errorcontext_strdata + g_errorcontext_stroffset[i]) ;
      TEST(0 == strcmp("Unknown error", errstr)) ;
      TEST(g_errorcontext_stroffset[i]      == g_errorcontext_stroffset[1+maxsyserrnum_errorcontext()]) ;
      TEST(lengthof(g_errorcontext_strdata) == g_errorcontext_stroffset[1+maxsyserrnum_errorcontext()]+strlen(errstr)+1) ;
   }

   // TEST str_errorcontext: 0 <= errno < 512
   // g_errorcontext_stroffset has 256(syserror) + 256(extended error) entries so str_errorcontext can use (uint8_t) to mask index
   TEST(512 == lengthof(g_errorcontext_stroffset)) ;
   // g_errorcontext_strdata: last byte is '\0' byte
   TEST(0 == g_errorcontext_strdata[lengthof(g_errorcontext_strdata)-1]) ;
   TEST(0 != g_errorcontext_strdata[lengthof(g_errorcontext_strdata)-2]) ;
   for (size_t i = 0; i <= 255; ++i) {
      const char * errstr = (const char*) (g_errorcontext_strdata + g_errorcontext_stroffset[i]) ;
      TEST(lengthof(g_errorcontext_strdata) > g_errorcontext_stroffset[i]) ;
      TEST(lengthof(g_errorcontext_strdata) > g_errorcontext_stroffset[i] + strlen(errstr)) ;
      if (i <= maxsyserrnum_errorcontext()) {
         TEST(0 == strcmp(errstr, strerror((int)i))) ;
      } else {
         TEST(0 == strcmp(errstr, "Unknown error")) ;
      }
      TEST((const uint8_t*)errstr == str_errorcontext(errcontext, i)) ;
   }

   // TEST str_errorcontext: 255 <= errno <= SIZE_MAX
   for (size_t i = 255; true; i *= 2, ++i) {
      const uint8_t * errstr = g_errorcontext_strdata + g_errorcontext_stroffset[255] ;
      TEST(errstr == str_errorcontext(errcontext, i)) ;
      if (i == SIZE_MAX) break ;
   }

   // unprepare
   TEST(0 == free_errorcontext(&errcontext)) ;

   return 0 ;
ONABORT:
   free_errorcontext(&errcontext) ;
   return EINVAL ;
}

static int test_generic(void)
{
   errorcontext_t errcontext ;
   struct {
      uint16_t *  stroffset ;
      uint8_t  *  strdata ;
   }              errcontext2 ;

   // TEST genericcast_errorcontext
   TEST(&errcontext                   == genericcast_errorcontext(&errcontext)) ;
   TEST((errorcontext_t*)&errcontext2 == genericcast_errorcontext(&errcontext2)) ;

   // TEST init_errorcontext
   TEST(0 == init_errorcontext(genericcast_errorcontext(&errcontext2))) ;

   // TEST str_errorcontext
   const uint8_t * errstr = str_errorcontext(errcontext2, maxsyserrnum_errorcontext()+1) ;
   TEST(errstr != 0) ;
   TEST(0 == strcmp((const char*)errstr, "Unknown error")) ;

   // TEST free_errorcontext
   TEST(0 == init_errorcontext(genericcast_errorcontext(&errcontext2))) ;

   return 0 ;
ONABORT:
   return EINVAL ;
}

static int test_initonce(void)
{
   errorcontext_t errcontext = errorcontext_INIT_FREEABLE ;


   // TEST initonce_errorcontext
   TEST(0 == initonce_errorcontext(&errcontext)) ;
   TEST(errcontext.stroffset == g_errorcontext_stroffset) ;
   TEST(errcontext.strdata   == g_errorcontext_strdata) ;

   // TEST freeonce_errorcontext: no-op
   TEST(0 == freeonce_errorcontext(&errcontext)) ;
   TEST(errcontext.stroffset == g_errorcontext_stroffset) ;
   TEST(errcontext.strdata   == g_errorcontext_strdata) ;

   return 0 ;
ONABORT:
   return EINVAL ;
}


int unittest_context_errorcontext()
{
   resourceusage_t   usage     = resourceusage_INIT_FREEABLE ;
   char              msglocale[100] = { 0 } ;

   // switch system error messages returned from strerror to english
   const char * prevlocale = setlocale(LC_MESSAGES, "C") ;
   if (prevlocale) strncpy(msglocale, prevlocale, sizeof(msglocale)) ;

   if (test_query())          goto ONABORT ;

   TEST(0 == init_resourceusage(&usage)) ;

   if (test_initfree())       goto ONABORT ;
   if (test_query())          goto ONABORT ;
   if (test_generic())        goto ONABORT ;
   if (test_initonce())       goto ONABORT ;

   TEST(0 == same_resourceusage(&usage)) ;
   TEST(0 == free_resourceusage(&usage)) ;

   setlocale(LC_MESSAGES, msglocale) ;

   return 0 ;
ONABORT:
   (void) free_resourceusage(&usage) ;
   return EINVAL ;
}

#endif
