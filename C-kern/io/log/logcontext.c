/* title: LogContext impl

   Implements <LogContext>.

   Copyright:
   This program is free software. See accompanying LICENSE file.

   Author:
   (C) 2018 JÃ¶rg Seebohn

   file: C-kern/api/io/log/logcontext.h
    Header file <LogContext>.

   file: C-kern/io/log/logcontext.c
    Implementation file <LogContext impl>.
*/

#include "C-kern/konfig.h"
#include "C-kern/api/io/log/logcontext.h"
#include "C-kern/api/err.h"
#ifdef KONFIG_UNITTEST
#include "C-kern/api/test/unittest.h"
#endif


// section: logcontext_t

// group: static variables

#include STR(C-kern/resource/generated/errtab.KONFIG_LANG) // generated by text resource compiler

// group: lifetime

int init_logcontext(/*out*/logcontext_t* lc)
{
   static_assert(512 == lengthof(s_logcontext_err_offsets), "All entries defined");
   lc->err = (logcontext_error_t) logcontext_error_INIT(s_logcontext_err_offsets, s_logcontext_err_strings);
   return 0;
}

int free_logcontext(logcontext_t* lc)
{
   *lc = (logcontext_t) logcontext_FREE;
   return 0;
}


// group: query

int isfree_logcontext(const logcontext_t* lc)
{
   return   0 == lc->err.offsets
            && 0 == lc->err.strings;
}

uint16_t maxsyserrno_logcontext(void)
{
   return 133;
}


// section: Functions

// group: test

#ifdef KONFIG_UNITTEST

static int test_errtable_match_OStable(void)
{
   logcontext_t lc = logcontext_FREE;
   TEST(0 == init_logcontext(&lc));

   // !! this works currently only for KONFIG_LANG set to en !!
   setlocale(LC_MESSAGES, "C");
   for (unsigned i=0; i<=maxsyserrno_logcontext(); ++i) {
      const char* expect = strerror((int)i); // error description returned by OS
      const char* errstr = (const char*) errstr_logcontext(&lc, i);
      TESTP(0 == strcmp(expect, errstr), "i:%d", i);
   }

   // reset
   TEST(0 == free_logcontext(&lc));

   return 0;
ONERR:
   free_logcontext(&lc);
   return EINVAL;
}

static int test_error(void)
{
   logcontext_error_t ec = logcontext_error_FREE;

   // === group: lifetime

   // TEST logcontext_error_FREE
   TEST(0 == ec.offsets);
   TEST(0 == ec.strings);

   // prepare
   logcontext_t lc = logcontext_FREE;
   TEST(0 == init_logcontext(&lc));

   // === group: query

   // TEST s_logcontext_err_strings: last byte is '\0' byte
   TEST(0 == s_logcontext_err_strings[lengthof(s_logcontext_err_strings)-1]);
   TEST(0 != s_logcontext_err_strings[lengthof(s_logcontext_err_strings)-2]);

   // TEST maxsyserrno_logcontext: check returned value is correct
   TEST(0 < maxsyserrno_logcontext() && maxsyserrno_logcontext() < 255);
   for (unsigned i=1u+maxsyserrno_logcontext(); i<=255; ++i) {
      const uint8_t* unknown = errstr_logcontext(&lc, 255);
      const char* expect_de = "Unbekannter Fehler";
      const char* expect_en = "Unknown error";
      const uint8_t* errstr = errstr_logcontext(&lc, i);
      (void) expect_de; (void) expect_en; // no warning for unsued variable
      // check unknown error code
      TEST(0 == strcmp(CONCAT(expect_, KONFIG_LANG), (const char*)errstr));
      TEST(unknown == errstr);
   }

   // TEST errstr_logcontext: check system error codes
   for (unsigned i=0; i<=maxsyserrno_logcontext(); ++i) {
      const uint8_t* unknown = errstr_logcontext(&lc, 255);
      const char* expect_de = "Unbekannter Fehler";
      const char* expect_en = "Unknown error";
      const uint8_t* errstr = errstr_logcontext(&lc, i);
      (void) expect_de; (void) expect_en; // no warning for unsued variable
      // check not unknown error code
      TEST(0 != strcmp(CONCAT(expect_, KONFIG_LANG), (const char*)errstr));
      TEST(unknown != errstr);
   }

   // TEST errstr_logcontext: check system error descriptions match descriptions of err table
   int err;
   TEST(0 == execasprocess_unittest(&test_errtable_match_OStable, &err));
   TEST(0 == err);

   // TEST errstr_logcontext: defined application error codes
   for (unsigned i=256; i<errornr_NEXTERRORCODE; ++i) {
      const uint8_t* unknown = errstr_logcontext(&lc, 255);
      // valid content
      TEST(unknown != errstr_logcontext(&lc, i));
   }

   // TEST errstr_logcontext: undefined application error codes
   for (unsigned i=errornr_NEXTERRORCODE; i<512; ++i) {
      const uint8_t* unknown = errstr_logcontext(&lc, 255);
      TEST(unknown == errstr_logcontext(&lc, i));
   }

   // TEST errstr_logcontext: error codes > 511
   for (unsigned i=512; i; i<<=1) {
      const uint8_t* unknown = errstr_logcontext(&lc, 255);
      TEST(unknown == errstr_logcontext(&lc, i));
   }

   // reset
   TEST(0 == free_logcontext(&lc));

   return 0;
ONERR:
   free_logcontext(&lc);
   return EINVAL;
}

static int test_initfree(void)
{
   logcontext_t lc = logcontext_FREE;

   // TEST logcontext_FREE
   TEST(0 == lc.err.offsets);
   TEST(0 == lc.err.strings);

   // TEST init_logcontext
   TEST(0 == init_logcontext(&lc));
   TEST(lc.err.offsets == s_logcontext_err_offsets);
   TEST(lc.err.strings == s_logcontext_err_strings);

   // TEST free_logcontext
   TEST(0 == free_logcontext(&lc));
   TEST(0 == lc.err.offsets);
   TEST(0 == lc.err.strings);

   return 0;
ONERR:
   return EINVAL;
}

static int test_query(void)
{
   logcontext_t lc = logcontext_FREE;

   // TEST isfree_logcontext
   TEST( 1 == isfree_logcontext(&lc));
   lc.err.offsets = (void*)1;
   TEST( 0 == isfree_logcontext(&lc));
   lc.err.offsets = 0;
   lc.err.strings = (void*)1;
   TEST( 0 == isfree_logcontext(&lc));
   lc.err.strings = 0;
   TEST( 1 == isfree_logcontext(&lc));

   return 0;
ONERR:
   return EINVAL;
}

int unittest_io_log_logcontext()
{
   if (test_error())          goto ONERR;
   if (test_initfree())       goto ONERR;
   if (test_query())          goto ONERR;

   return 0;
ONERR:
   return EINVAL;
}

#endif
